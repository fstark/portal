0: 	ORG 0F7E9H
0F7E9H: ;
0F7E9H: ; R2E Micral Portal boot rom disassembly (in progress) 
0F7E9H: ; This code is executed from 0 and copies the rest into F800 in RAM
0F7E9H: ;
0F7E9H: IGNORE:   ; 0F7E9H
0F7E9H: 	DI
0F7EAH: 	LXI H,17H            ; From address 0017H
0F7EDH: 	LXI B,41CH           ; Copy 041CH bytes (1052 bytes)
0F7F0H: 	LXI D,RAM_START      ; To location @RAM_START...
0F7F3H: 	MOV A,M
0F7F4H: 	STAX D
0F7F5H: 	INX H
0F7F6H: 	INX D
0F7F7H: 	DCX B
0F7F8H: ;
0F7F8H: ; Copies the code 'JMP FA7A' (HOOK) here
0F7F8H: ; This is also written to by F809H and becomes @INT_VECTOR
0F7F8H: ; (JMP @FA7AH / JMP @INTERRUPT)
0F7F8H: ; PIC sets interrupts to be at F7E0+4*INT#, so this is INT 6.
0F7F8H: ;
0F7F8H: INT_VECTOR:   ; 0F7F8H
0F7F8H: 	MOV A,B
0F7F9H: 	ORA C
0F7FAH: 	JNZ 0AH              ; This is @f7f3H in offseted binary
0F7FDH: 	JMP RAM_START        ; Jump to copied code
0F800H: ;
0F800H: ; The real start in RAM
0F800H: ; Ports:
0F800H: ;   11: 00
0F800H: ;   60: F6
0F800H: ;   61: F7 BF
0F800H: ;
0F800H: RAM_START:   ; 0F800H
0F800H: 	MVI A,0C0H
0F802H: 	SIM                  ; Unmap ROM (set 40H to put ROM back)
0F803H: 	LXI SP,CURSOR
0F806H: 	XRA A
0F807H: 	OUT 11H
0F809H: 	LXI H,INT_VECTOR
0F80CH: 	MVI M,0C3H           ; JMP
0F80EH: 	INX H
0F80FH: 	MVI M,7AH            ; LOW(@INTERRUPT)
0F811H: 	INX H
0F812H: 	MVI M,0FAH           ; HI(@INTERRUPT)
0F814H: 	MVI A,0F6H           ; ICW1 : PIC init word 1
0F816H: 	OUT 60H
0F818H: 	MVI A,0F7H           ; ICW2 : PIC init word 2 (interrupt at F7E0+4*INT)
0F81AH: 	OUT 61H
0F81CH: 	MVI A,0BFH           ; ICW3 : PIC init word 3
0F81EH: 	OUT 61H
0F820H: 	XRA A
0F821H: 	STA SKIP_INTERRUP    ; Some flag?
0F824H: ;
0F824H: ; Resets stack, print 
0F824H: ;
0F824H: MONITOR:   ; 0F824H
0F824H: 	LXI SP,CURSOR
0F827H: 	CALL PRINT_LF
0F82AH: 	LXI H,PSTR_PORTAL
0F82DH: 	CALL PRINT_PSTR
0F830H: 	LXI H,PROLOGUE       ; Load adrs. Can be changed by the @CMD_AMP command
0F833H: 	SHLD BOOT_HL
0F836H: 	LXI D,80H            ; Can be changed by the @CMD_B command. I Suspect it is some track/sector
0F839H: MONITOR2:   ; 0F839H
0F839H: 	MVI B,0              ; 0 to 3, can be changed by @CMD_B command
0F83BH: 	CALL READ_CHAR_ECHO
0F83EH: 	MOV A,C
0F83FH: 	CPI 26H
0F841H: 	JZ CMD_AMP           ; '&' command
0F844H: 	CPI 0DH
0F846H: 	XCHG
0F847H: 	JZ CMD_ENTER         ; '
' command
0F84AH: 	CPI 2AH
0F84CH: 	JZ CMD_STAR          ; '*' command
0F84FH: 	MOV B,A
0F850H: 	MVI C,3AH            ; ':'
0F852H: 	CALL PRINT_CHAR
0F855H: 	MVI A,47H
0F857H: 	CMP B
0F858H: 	JZ CMD_G             ; 'G' command
0F85BH: 	MVI A,42H
0F85DH: 	CMP B
0F85EH: 	JNZ MONITOR_REENTER
0F861H: ;
0F861H: ; Here the 'B' (Boot ?) command starts
0F861H: ; Asks for a 0-3 number (drive #?)
0F861H: ; then a 4 hex number (#of bytes to read? sector?)
0F861H: ; and executes the 'ENTER' function (real boot)
0F861H: ;
0F861H: CMD_B:   ; 0F861H
0F861H: 	CALL READ_HL         ; Drive #
0F864H: 	JNC MONITOR_REENTER
0F867H: 	MOV A,H
0F868H: 	ORA A
0F869H: 	JNZ MONITOR_REENTER
0F86CH: 	MOV A,L
0F86DH: 	CPI 4
0F86FH: 	JNC MONITOR_REENTER  ; Must be 0 to 3
0F872H: 	MOV B,L
0F873H: 	CALL READ_HL         ; Size? Len? @F836H (defaults to 0080)
0F876H: 	JNC MONITOR_REENTER
0F879H: ;
0F879H: ; B : Drive #
0F879H: ;
0F879H: CMD_ENTER:   ; 0F879H
0F879H: 	MVI A,1
0F87BH: 	STA SKIP_INTERRUP    ; We skip interrupt code
0F87EH: 	MVI A,30H
0F880H: 	OUT 11H
0F882H: 	LXI D,84C6H          ; 33990 (loop counter)
0F885H: 	EI
0F886H: WAIT_LOOP:   ; 0F886H
0F886H: 	XTHL                 ; Waste some cycles
0F887H: 	XTHL
0F888H: 	DCX D
0F889H: 	MOV A,E
0F88AH: 	ORA D
0F88BH: 	JNZ WAIT_LOOP        ; Loops 33990 times
0F88EH: 	DI
0F88FH: 	XRA A
0F890H: 	STA SKIP_INTERRUP    ; We activate the @INTERRUPT code
0F893H: 	SHLD XXX_PTR1        ; 0080 or something that was entered with the 'B' command
0F896H: 	MOV A,B
0F897H: 	STA DRIVE
0F89AH: 	LXI H,DATA_S0
0F89DH: 	LXI D,DATA51H_3
0F8A0H: 	MVI A,3
0F8A2H: 	STAX D
0F8A3H: 	INX D
0F8A4H: 	MVI C,2
0F8A6H: 	CALL MEMCPY
0F8A9H: 	MVI C,3
0F8ABH: 	LXI H,DATA51H_3      ; Contains [3,'S','0']
0F8AEH: 	CALL WRITE2_51H
0F8B1H: 	LXI H,0FFFFH
0F8B4H: 	SHLD BUFFER          ; Drive 0 & 1
0F8B7H: 	SHLD BUFFER+2        ; Drive 2 & 3
0F8BAH: 	LXI H,DATA51H_3+3
0F8BDH: 	MVI M,4
0F8BFH: 	MVI C,2
0F8C1H: 	CALL WRITE2_51H
0F8C4H: 	CALL READ_51H
0F8C7H: 	MOV A,M              ; Wtf is this code?
0F8C8H: 	ANI 8                ; ?
0F8CAH: 	RLC                  ; ?
0F8CBH: 	RLC                  ; ?
0F8CCH: 	RLC                  ; ?
0F8CDH: 	RLC                  ; ?
0F8CEH: 	MVI A,40H            ; ?
0F8D0H: 	ORI 6                ; We juste did an MVI A,46H
0F8D2H: 	STA DATA51H_3+3
0F8D5H: 	LXI H,DATA_TR        ; Contains 28H
0F8D8H: 	RLC                  ; Why?
0F8D9H: 	MOV A,M
0F8DAH: 	JNC SKIP_383         ; C is always 0
0F8DDH: 	RLC
0F8DEH: SKIP_383:   ; 0F8DEH
0F8DEH: 	INX H
0F8DFH: 	INX H
0F8E0H: 	MOV L,M              ; Normally will put 10H in L (from @FB01H)
0F8E1H: 	MOV H,A
0F8E2H: 	SHLD XXX_PTR2
0F8E5H: 	LHLD BOOT_HL
0F8E8H: 	XCHG
0F8E9H: 	LXI H,0
0F8ECH: 	SHLD XXX_LEN4        ; The buffer starts empty
0F8EFH: ;
0F8EFH: ; Redoes whatever this function tries to do.
0F8EFH: ; WEIRD ends here if C is zero
0F8EFH: ;
0F8EFH: AGAIN:   ; 0F8EFH
0F8EFH: 	CALL WEIRD
0F8F2H: 	ANA A                ; A=0 ?
0F8F3H: 	JZ MONITOR_REENTER
0F8F6H: 	MOV C,A              ; C = GET()
0F8F7H: 	CALL WEIRD
0F8FAH: 	MOV B,A              ; B = GET()
0F8FBH: 	MOV A,C
0F8FCH: 	CPI 3
0F8FEH: 	JC DF912             ; IF C < 3 ...
0F901H: 	CALL WEIRD
0F904H: 	MOV H,A              ; H = GET()
0F905H: 	CALL WEIRD
0F908H: 	MOV L,A              ; L = GET()
0F909H: 	CALL WEIRD
0F90CH: 	ANI 1                ; IF GET()&1 THEN DE++
0F90EH: 	JZ DF912
0F911H: 	DAD D
0F912H: DF912:   ; 0F912H
0F912H: 	MOV A,B
0F913H: 	CPI 0C2H
0F915H: 	JZ DF932             ; IF B=C2 THEN F932
0F918H: 	CPI 0D2H
0F91AH: 	JZ DF93E             ; IF B=D2 THEN F93E
0F91DH: 	CPI 0C6H
0F91FH: 	JZ JMP_HL            ; Execute some loaded code?
0F922H: 	CPI 0C1H
0F924H: 	JC MONITOR_REENTER   ; IF B=C1 THEN ABORT()
0F927H: 	CPI 0DBH
0F929H: 	JNC MONITOR_REENTER  ; IF B=DB THEN ABORT()
0F92CH: DF92C:   ; 0F92CH
0F92CH: 	CALL WEIRD
0F92FH: 	JMP DF92C            ; FOR (;;) GET()
0F932H: DF932:   ; 0F932H
0F932H: 	CALL WEIRD
0F935H: 	MOV M,A
0F936H: 	CMP M
0F937H: 	JNZ MONITOR_REENTER  ; Looks like we are trying to write to ROM
0F93AH: 	INX H
0F93BH: 	JMP DF932
0F93EH: ;
0F93EH: ; After the call to @WEIRD, it does something strange:
0F93EH: ; Breaks A into 4 groups of two bits
0F93EH: ; Ensure those groups are 00 or 01
0F93EH: ; When they are 01, it adds DE to (HL,H+1)
0F93EH: ; HL is in incremented between each loop.
0F93EH: ;
0F93EH: DF93E:   ; 0F93EH
0F93EH: 	CALL WEIRD
0F941H: 	MVI B,4              ; Will work on the 4 group of 2 bits
0F943H: LOOP_383:   ; 0F943H
0F943H: 	RLC
0F944H: 	JC MONITOR_REENTER   ; 10 or 11 => ABORT()
0F947H: 	RLC
0F948H: 	JNC SKIP_ADD
0F94BH: 	PUSH PSW             ; All this does: (HL,HL+1) += DE
0F94CH: 	MOV A,M
0F94DH: 	ADD E
0F94EH: 	MOV M,A              ; (HL) += E
0F94FH: 	INX H
0F950H: 	MOV A,M
0F951H: 	ADC D
0F952H: 	MOV M,A              ; (HL+1) += D (with carry from above)
0F953H: 	DCX H
0F954H: 	POP PSW
0F955H: SKIP_ADD:   ; 0F955H
0F955H: 	INX H
0F956H: 	DCR B
0F957H: 	JNZ LOOP_383
0F95AH: 	JMP DF93E
0F95DH: ;
0F95DH: ; Jumps to content of HL
0F95DH: ;
0F95DH: JMP_HL:   ; 0F95DH
0F95DH: 	PCHL
0F95EH: ;
0F95EH: ; Weird function with a spurious POP if C is zero...
0F95EH: ; If C is not zero it reads one byte from @XXX_PTR3
0F95EH: ;
0F95EH: WEIRD:   ; 0F95EH
0F95EH: 	INR C
0F95FH: 	DCR C
0F960H: 	JNZ NON_ZERO_C       ; If C!=0 GOTO NON_ZERO_C
0F963H: 	POP PSW              ; Weird...
0F964H: 	INR C                ; C = 1
0F965H: 	JMP AGAIN            ; Again
0F968H: ;
0F968H: ; Called when C is not Zero. Why? No idea yet.
0F968H: ; Reads one byte out of @XXX_PTR3 until @XXX_LEN4 is zero
0F968H: ; Resets @XXX_LEN4 to FF and @XXX_PTR to @XXX_BUFFER at last element
0F968H: ;
0F968H: NON_ZERO_C:   ; 0F968H
0F968H: 	PUSH H
0F969H: 	LHLD XXX_LEN4        ; HL = @XXX_LEN4
0F96CH: 	MOV A,H
0F96DH: 	ORA L
0F96EH: 	JNZ NOT_EMPTY        ; IF HL != 0 GOTO NOT_EMPTY
0F971H: ;
0F971H: ; Buffer is empty
0F971H: ;
0F971H: EMPTY:   ; 0F971H
0F971H: 	PUSH H
0F972H: 	PUSH D
0F973H: 	PUSH B
0F974H: 	LHLD XXX_PTR2
0F977H: 	XCHG
0F978H: 	LHLD XXX_PTR1
0F97BH: 	CALL DIV             ; HL = HL / E
0F97EH: 	SHLD XXX_PTR1        ; @XXX_PTR1 = @XXX_PTR1 / @XXX_PTR2 (first byte)
0F981H: 	POP B
0F982H: 	POP D
0F983H: 	POP H
0F984H: 	LXI H,0FFH
0F987H: 	SHLD XXX_LEN4        ; @XXX_LEN4 = FF
0F98AH: 	LXI H,XXX_BUFFER     ; HL = &XXX_BUFFER (reset @XXX_PTR3 buffer)
0F98DH: 	JMP DF997
0F990H: NOT_EMPTY:   ; 0F990H
0F990H: 	DCX H                ; HL--
0F991H: 	SHLD XXX_LEN4        ; @XXX_LEN4 = HL
0F994H: 	LHLD XXX_PTR3
0F997H: DF997:   ; 0F997H
0F997H: 	MOV A,M              ; Get next from @XXX_PTR3
0F998H: 	INX H                ; @XXX_PTR3++
0F999H: 	SHLD XXX_PTR3        ; XXX_PTR3++ or XXX_PTR3=&XXX_BUFFER after every 256 bytes
0F99CH: 	POP H
0F99DH: 	DCR C
0F99EH: 	RET
0F99FH: ;
0F99FH: ; Divides HL by E
0F99FH: ;   (E may be C6H (198) from '@CMD_ENTER'?)
0F99FH: ;
0F99FH: DIV:   ; 0F99FH
0F99FH: 	PUSH H
0F9A0H: 	PUSH D
0F9A1H: 	XRA A
0F9A2H: 	MVI D,10H
0F9A4H: ;
0F9A4H: ; 16 times (every bit of HL)
0F9A4H: ;
0F9A4H: LOOP:   ; 0F9A4H
0F9A4H: 	DAD H                ; C = HL & 8000 ; HL <<= 1
0F9A5H: 	RAL                  ; A gets the high bit of HL
0F9A6H: 	JC BIT7
0F9A9H: 	CMP E
0F9AAH: 	JC SKIP_217          ; A < E
0F9ADH: BIT7:   ; 0F9ADH
0F9ADH: 	INR L                ; L |= 1
0F9AEH: 	SUB E
0F9AFH: SKIP_217:   ; 0F9AFH
0F9AFH: 	DCR D
0F9B0H: 	JNZ LOOP
0F9B3H: 	INR A
0F9B4H: 	STA DRIVE+3
0F9B7H: 	MOV A,L
0F9B8H: 	POP D
0F9B9H: 	CMP D
0F9BAH: 	JNC MONITOR_REENTER
0F9BDH: 	LDA DATA51H_3+3
0F9C0H: 	RLC
0F9C1H: 	MVI B,0
0F9C3H: 	MOV A,L
0F9C4H: 	JNC SKIP
0F9C7H: 	ORA A
0F9C8H: 	RAR
0F9C9H: 	JNC SKIP
0F9CCH: 	MVI B,4
0F9CEH: SKIP:   ; 0F9CEH
0F9CEH: 	STA DRIVE+1
0F9D1H: 	LXI H,DRIVE
0F9D4H: 	MOV A,B
0F9D5H: 	ORA M
0F9D6H: 	MOV M,A
0F9D7H: 	MOV A,B
0F9D8H: 	RRC
0F9D9H: 	RRC
0F9DAH: 	STA DRIVE+2
0F9DDH: 	LXI H,DATA_X4        ; 01 10 20 00
0F9E0H: 	MVI C,4
0F9E2H: 	LXI D,DRIVE+4
0F9E5H: 	CALL MEMCPY
0F9E8H: LOOP_609:   ; 0F9E8H
0F9E8H: 	MVI A,3FH
0F9EAH: 	OUT 40H
0F9ECH: 	MVI A,0FCH
0F9EEH: 	OUT 40H
0F9F0H: 	MVI A,0FFH
0F9F2H: 	OUT 41H
0F9F4H: 	MVI A,40H
0F9F6H: 	OUT 41H
0F9F8H: 	MVI A,0E5H
0F9FAH: 	OUT 48H
0F9FCH: 	CALL XXX_635
0F9FFH: 	MVI C,9              ; Read 9 bytes
0FA01H: 	LXI H,DATA51H_3+3
0FA04H: 	CALL XXX_891
0FA07H: 	DCR A
0FA08H: 	JNZ DFA0E
0FA0BH: 	POP H
0FA0CH: 	INX H
0FA0DH: 	RET
0FA0EH: DFA0E:   ; 0FA0EH
0FA0EH: 	LDA FLAG2+1
0FA11H: 	ANI 84H
0FA13H: 	JZ LOOP_609
0FA16H: 	CALL DFA27
0FA19H: 	MVI M,0FFH
0FA1BH: 	JMP LOOP_609
0FA1EH: ;
0FA1EH: ; Copies C bytes from HL to DE
0FA1EH: ;
0FA1EH: MEMCPY:   ; 0FA1EH
0FA1EH: 	MOV A,M
0FA1FH: 	STAX D
0FA20H: 	INX H
0FA21H: 	INX D
0FA22H: 	DCR C
0FA23H: 	JNZ MEMCPY
0FA26H: 	RET
0FA27H: ;
0FA27H: ; HL = @BUFFER + @DRIVE & 0x3
0FA27H: ;
0FA27H: DFA27:   ; 0FA27H
0FA27H: 	LDA DRIVE
0FA2AH: 	ANI 3
0FA2CH: 	LXI H,BUFFER
0FA2FH: 	ADD L
0FA30H: 	MOV L,A
0FA31H: 	RNC
0FA32H: 	INR H
0FA33H: 	RET
0FA34H: XXX_635:   ; 0FA34H
0FA34H: 	CALL DFA27
0FA37H: 	MOV A,M
0FA38H: 	INR A
0FA39H: 	JZ 0FA5FH
0FA3CH: 	LDA DRIVE+1
0FA3FH: 	CMP M
0FA40H: 	RZ
0FA41H: 	ORA A
0FA42H: 	XCHG
0FA43H: 	JZ 0FA69H
0FA46H: 	LXI H,DATA51H_3+2
0FA49H: 	MOV M,A
0FA4AH: 	MVI B,0FH
0FA4CH: 	MVI C,3
0FA4EH: 	LXI H,DATA51H_3+1
0FA51H: 	LDA DRIVE
0FA54H: 	MOV M,A
0FA55H: 	DCX H
0FA56H: 	MOV M,B
0FA57H: 	CALL XXX_891
0FA5AH: 	LDA DRIVE+1
0FA5DH: 	STAX D
0FA5EH: 	RET
0FA5FH: 	XCHG
0FA60H: 	CALL 0FA69H
0FA63H: 	XCHG
0FA64H: 	MVI M,0
0FA66H: 	JMP 0FA3CH
0FA69H: 	MVI B,7
0FA6BH: 	MVI C,2
0FA6DH: 	CALL 0FA4EH
0FA70H: 	LDA FLAG3
0FA73H: 	DCR A
0FA74H: 	MVI A,0
0FA76H: 	RZ
0FA77H: 	JMP 0FA69H
0FA7AH: ;
0FA7AH: ; Interrupt?
0FA7AH: ; Stored as the target of a JMP instruction in 0008
0FA7AH: ; (See RAM_START)
0FA7AH: ;
0FA7AH: INTERRUPT:   ; 0FA7AH
0FA7AH: 	PUSH PSW
0FA7BH: 	PUSH B
0FA7CH: 	PUSH H
0FA7DH: 	LDA SKIP_INTERRUP
0FA80H: 	ANA A
0FA81H: 	JNZ INTERRUPT_END    ; Skip interrupt code
0FA84H: ;
0FA84H: ; Reads from 51H
0FA84H: ;
0FA84H: INTERRUPT_READ:   ; 0FA84H
0FA84H: 	CALL READ_51H
0FA87H: 	MOV A,B              ; B is length (0 or 1)
0FA88H: 	ANA A
0FA89H: 	JZ INTERRUPT_RETRY   ; B=0 => No data read
0FA8CH: 	LXI H,FLAG2
0FA8FH: 	MOV A,M              ; Data read from 51H
0FA90H: 	RLC
0FA91H: 	JC INTERRUPT_ERROR   ; Checks it is 0xxxxxxx
0FA94H: 	RLC
0FA95H: 	JC INTERRUPT_ERROR   ; Checks it is 00xxxxxx
0FA98H: 	MVI A,1              ; Signal we are done
0FA9AH: ;
0FA9AH: ; Returns with a code (in @FLAG3)
0FA9AH: ;
0FA9AH: INTERRUPT_RETURN:   ; 0FA9AH
0FA9AH: 	STA FLAG3
0FA9DH: INTERRUPT_END:   ; 0FA9DH
0FA9DH: 	MVI A,66H            ; (Probably some sort of acknowledgment)
0FA9FH: 	OUT 60H
0FAA1H: 	POP H
0FAA2H: 	POP B
0FAA3H: 	POP PSW
0FAA4H: 	RET
0FAA5H: ;
0FAA5H: ; I suspect this is an error code
0FAA5H: ;
0FAA5H: INTERRUPT_ERROR:   ; 0FAA5H
0FAA5H: 	MVI A,7FH
0FAA7H: 	JMP INTERRUPT_RETURN
0FAAAH: ;
0FAAAH: ; I guess this is a retry to get some data
0FAAAH: ; (writes 1 in bit 4 of 51H)
0FAAAH: ;
0FAAAH: INTERRUPT_RETRY:   ; 0FAAAH
0FAAAH: 	LXI H,DATA51H_3
0FAADH: 	MVI M,8
0FAAFH: 	MVI C,1
0FAB1H: 	CALL WRITE_51H       ; Write [0x08]
0FAB4H: 	JMP INTERRUPT_READ
0FAB7H: ;
0FAB7H: ; Reads from 51H into PORT51_INDATA
0FAB7H: ; Reads as long as 50H bits 6 and 7 are set
0FAB7H: ; Stops if 50H has bit 7 set and bit 5 cleared
0FAB7H: ; B contains number of bytes read
0FAB7H: ; Also called from interrupt
0FAB7H: ;
0FAB7H: READ_51H:   ; 0FAB7H
0FAB7H: 	LXI H,PORT51_INDATA  ; Actually @FLAG2-1
0FABAH: 	MVI B,0
0FABCH: LOOP_576:   ; 0FABCH
0FABCH: 	IN 50H
0FABEH: 	RLC
0FABFH: 	JNC LOOP_576         ; Wait for bit 7
0FAC2H: 	MOV C,A
0FAC3H: 	ANI 20H              ; 0010 0000
0FAC5H: 	RZ                   ; Return if 5th bit clear
0FAC6H: 	MOV A,C
0FAC7H: 	RLC
0FAC8H: 	JNC LOOP_576         ; Wait for bit 6
0FACBH: 	IN 51H
0FACDH: 	INX H                ; @FLAG2 (@PORT51_INDATA+1)
0FACEH: 	INR B
0FACFH: 	MOV M,A
0FAD0H: 	JMP LOOP_576
0FAD3H: ;
0FAD3H: ; Write C chars into HL (from floppy?)
0FAD3H: ; Waits for 50H bit 4 to clear
0FAD3H: ; Then similar logic to READ:
0FAD3H: ; Waits for bit 7 set and 6 cleared
0FAD3H: ;
0FAD3H: WRITE_51H:   ; 0FAD3H
0FAD3H: 	IN 50H
0FAD5H: 	ANI 10H
0FAD7H: 	JNZ WRITE_51H
0FADAH: ;
0FADAH: ; Writes C chars from HL to 51H
0FADAH: ; (waits for 50H bit 7 to be set)
0FADAH: ;
0FADAH: WRITE2_51H:   ; 0FADAH
0FADAH: 	IN 50H
0FADCH: 	RLC
0FADDH: 	JNC WRITE2_51H
0FAE0H: 	RLC
0FAE1H: 	JC WRITE2_51H
0FAE4H: 	MOV A,M
0FAE5H: 	OUT 51H
0FAE7H: 	INX H
0FAE8H: 	DCR C
0FAE9H: 	JNZ WRITE2_51H
0FAECH: 	RET
0FAEDH: ;
0FAEDH: ; Suspects that is is read from floppy sync
0FAEDH: ;
0FAEDH: XXX_891:   ; 0FAEDH
0FAEDH: 	CALL WRITE_51H
0FAF0H: 	XRA A
0FAF1H: 	STA FLAG3
0FAF4H: 	EI
0FAF5H: BUSY_LOOP:   ; 0FAF5H
0FAF5H: 	LDA FLAG3            ; Interrup will set this to 1
0FAF8H: 	ORA A
0FAF9H: 	JZ BUSY_LOOP
0FAFCH: 	RET
0FAFDH: ;
0FAFDH: ; 2 bytes of data 
0FAFDH: ;
0FAFDH: DATA_S0:   ; 0FAFDH
0FAFDH: 	DB "S0",0
0FAFFH: ;
0FAFFH: ; Maybe track count? Inited at 40...
0FAFFH: ;
0FAFFH: DATA_TR:   ; 0FAFFH
0FAFFH: 	DB 28H               ; 28H = 40. Tracks?
0FB00H: ;
0FB00H: ; 4 bytes of data
0FB00H: ;
0FB00H: DATA_X4:   ; 0FB00H
0FB00H: 	DB 1,10H,20H,0,32H
0FB05H: ;
0FB05H: ; Reads HL in hex
0FB05H: ; Digits must be entered and finished with ESC
0FB05H: ; My understanding is that we will crash at the 8th digit
0FB05H: ;
0FB05H: READ_HL:   ; 0FB05H
0FB05H: 	PUSH B
0FB06H: 	LXI H,0              ; Starts with 0000
0FB09H: 	MVI B,9              ; Read at most 8 hex chars
0FB0BH: LOOP_811:   ; 0FB0BH
0FB0BH: 	CALL READ_CHAR_ECHO  ; Read one digit
0FB0EH: 	MOV A,C
0FB0FH: 	SUI 30H              ; ; '0' is at 0
0FB11H: 	JC FAILED            ; Fails if <'0'
0FB14H: 	ADI 0E9H             ; 'F' is at FF
0FB16H: 	JC FAILED            ; Fails if original char >'F'
0FB19H: 	ADI 6                ; 'A' is at 0
0FB1BH: 	JP SKIP_442          ; Jumps if original was 'A'-'F'
0FB1EH: 	ADI 7                ; '9' is at FF
0FB20H: 	JC FAILED            ; Jumps if orignal >'9' and <'A'
0FB23H: SKIP_442:   ; 0FB23H
0FB23H: 	ADI 0AH              ; '0' is at 0, 'F' at 15
0FB25H: 	ORA A                ; Why?
0FB26H: 	DCR B
0FB27H: 	JZ DONE              ; Will crash because lack of POP B
0FB2AH: 	DAD H                ; *2
0FB2BH: 	DAD H                ; *4
0FB2CH: 	DAD H                ; *8
0FB2DH: 	DAD H                ; *16
0FB2EH: 	ORA L                ; Why?
0FB2FH: 	MOV L,A              ; Replace last hex digit
0FB30H: 	JMP LOOP_811
0FB33H: FAILED:   ; 0FB33H
0FB33H: 	MOV A,C
0FB34H: 	CPI 1BH              ; ESC
0FB36H: 	POP B                ; Only correct way to exit
0FB37H: 	JZ DONE
0FB3AH: 	STC                  ; Error
0FB3BH: 	RET                  ; Return
0FB3CH: DONE:   ; 0FB3CH
0FB3CH: 	ORA A                ; Why?
0FB3DH: 	RET
0FB3EH: ;
0FB3EH: ; Weird infinite loop with echo of the type char (if not space).
0FB3EH: ; May be a keyboard tester
0FB3EH: ;
0FB3EH: CMD_STAR:   ; 0FB3EH
0FB3EH: 	MVI B,9              ; Probably current column
0FB40H: LOOP_230:   ; 0FB40H
0FB40H: 	CALL WAIT_KEY
0FB43H: 	MOV C,A
0FB44H: 	CPI 0DH              ; 

0FB46H: 	JZ LF
0FB49H: 	CPI 0AH              ; 
0FB4BH: 	JZ LF
0FB4EH: 	INR B                ; 0AH initial call
0FB4FH: 	MOV A,B
0FB50H: 	CPI 20H              ; ' '
0FB52H: 	JNZ CONT
0FB55H: 	CALL PRINT_LF
0FB58H: LF:   ; 0FB58H
0FB58H: 	MVI B,0
0FB5AH: 	CALL PRINT_CHAR
0FB5DH: 	JMP LOOP_230
0FB60H: CONT:   ; 0FB60H
0FB60H: 	CALL PRINT_CHAR      ; Useless should have been FB5A
0FB63H: 	JMP LOOP_230
0FB66H: ;
0FB66H: ; User typed 'G' in the monitor
0FB66H: ;
0FB66H: CMD_G:   ; 0FB66H
0FB66H: 	CALL READ_HL
0FB69H: 	JNC MONITOR_REENTER
0FB6CH: 	PCHL                 ; Jumpto address
0FB6DH: ;
0FB6DH: ; User typed '&' in the monitor
0FB6DH: ;
0FB6DH: CMD_AMP:   ; 0FB6DH
0FB6DH: 	CALL READ_HL
0FB70H: 	JNC MONITOR_REENTER
0FB73H: 	SHLD BOOT_HL
0FB76H: 	JMP MONITOR2
0FB79H: ;
0FB79H: ; Display '#' and goes to monitor
0FB79H: ;
0FB79H: MONITOR_REENTER:   ; 0FB79H
0FB79H: 	MVI C,23H            ; '#'
0FB7BH: 	CALL PRINT_CHAR
0FB7EH: 	JMP MONITOR
0FB81H: ;
0FB81H: ; Waits for a char and reads it in A
0FB81H: ;
0FB81H: WAIT_KEY:   ; 0FB81H
0FB81H: 	IN 10H               ; Char READY (bit 0)
0FB83H: 	RRC                  ; Bit 0 -> Carry
0FB84H: 	JNC WAIT_KEY         ; Wait for char
0FB87H: 	IN 11H               ; Char
0FB89H: 	ANI 7FH              ; Force ASCII
0FB8BH: 	RET
0FB8CH: ;
0FB8CH: ; TAB+SPACE+PORTAL
0FB8CH: ;
0FB8CH: PSTR_PORTAL:   ; 0FB8CH
0FB8CH: 	DB 9                 ; 9 Bytes string
0FB8DH: STR_PORTAL:   ; 0FB8DH
0FB8DH: 	DB " PORTAL..",0
0FB95H: 
0FB97H: ;
0FB97H: ; ? Unsure, maybe be reading a char
0FB97H: ;
0FB97H: READ_CHAR_ECHO:   ; 0FB97H
0FB97H: 	CALL WAIT_KEY
0FB9AH: 	MOV C,A
0FB9BH: ;
0FB9BH: ; Prints char in C
0FB9BH: ;
0FB9BH: PRINT_CHAR:   ; 0FB9BH
0FB9BH: 	MOV A,C
0FB9CH: 	CPI 0DH
0FB9EH: 	JZ PRINT_CR
0FBA1H: 	CPI 0AH
0FBA3H: 	JZ PRINT_LF
0FBA6H: 	PUSH H
0FBA7H: 	LHLD CURSOR
0FBAAH: 	MOV M,C
0FBABH: 	INX H
0FBACH: 	SHLD CURSOR
0FBAFH: 	MVI A,5FH            ; '_'
0FBB1H: 	MOV M,A
0FBB2H: 	CALL UPDATE_SCREEN
0FBB5H: 	POP H
0FBB6H: 	RET
0FBB7H: ;
0FBB7H: ; Erase current cursor and put cursor at start of screen
0FBB7H: ;
0FBB7H: PRINT_CR:   ; 0FBB7H
0FBB7H: 	PUSH H
0FBB8H: 	LHLD CURSOR
0FBBBH: 	MVI A,20H            ; ' '
0FBBDH: 	MOV M,A
0FBBEH: 	LXI H,SCREEN
0FBC1H: 	SHLD CURSOR
0FBC4H: 	MVI A,5FH            ; '_'
0FBC6H: 	MOV M,A
0FBC7H: 	CALL UPDATE_SCREEN
0FBCAH: 	POP H
0FBCBH: 	RET
0FBCCH: ;
0FBCCH: ; Outputs the content of @SCREEN to ports 9F downto 80 
0FBCCH: ;
0FBCCH: UPDATE_SCREEN:   ; 0FBCCH
0FBCCH: 	PUSH H
0FBCDH: 	PUSH B
0FBCEH: 	LXI H,SCREEN
0FBD1H: 	MVI B,9FH            ; Port
0FBD3H: LOOP_737:   ; 0FBD3H
0FBD3H: 	PUSH H
0FBD4H: 	LXI H,0FBDBH
0FBD7H: 	MOV M,B
0FBD8H: 	POP H
0FBD9H: 	MOV A,M
0FBDAH: 	OUT 9FH              ; Will be patched
0FBDCH: 	INX H
0FBDDH: 	DCR B
0FBDEH: 	MOV A,B
0FBDFH: 	CPI 7FH
0FBE1H: 	JNZ LOOP_737
0FBE4H: 	POP B
0FBE5H: 	POP H
0FBE6H: 	RET
0FBE7H: ;
0FBE7H: ; Clear screen, put cursor at column 0
0FBE7H: ;
0FBE7H: PRINT_LF:   ; 0FBE7H
0FBE7H: 	PUSH PSW
0FBE8H: 	PUSH B
0FBE9H: 	PUSH D
0FBEAH: 	PUSH H
0FBEBH: 	MVI A,20H            ; ' '
0FBEDH: 	LXI H,SCREEN
0FBF0H: 	MVI C,20H            ; Do 32 times (32 characters)
0FBF2H: NEXT_COLUMN:   ; 0FBF2H
0FBF2H: 	MOV M,A
0FBF3H: 	INX H
0FBF4H: 	DCR C
0FBF5H: 	JNZ NEXT_COLUMN      ; Copies 32 spaces
0FBF8H: 	LXI H,SCREEN
0FBFBH: 	MVI A,5FH            ; '_'
0FBFDH: 	MOV M,A              ; First char is '_'
0FBFEH: 	CALL UPDATE_SCREEN
0FC01H: 	LXI H,SCREEN
0FC04H: 	SHLD CURSOR          ; @CURSOR = @SCREEN (left column)
0FC07H: 	POP H
0FC08H: 	POP D
0FC09H: 	POP B
0FC0AH: 	POP PSW
0FC0BH: 	RET
0FC0CH: ;
0FC0CH: ; Prints pascal string pointed by HL
0FC0CH: ; First byte is length
0FC0CH: ;
0FC0CH: PRINT_PSTR:   ; 0FC0CH
0FC0CH: 	PUSH B
0FC0DH: 	PUSH H
0FC0EH: 	MOV B,M              ; Length
0FC0FH: LOOP_874:   ; 0FC0FH
0FC0FH: 	INX H
0FC10H: 	MOV C,M
0FC11H: 	CALL PRINT_CHAR
0FC14H: 	DCR B
0FC15H: 	JNZ LOOP_874
0FC18H: 	POP H
0FC19H: 	POP B
0FC1AH: 	RET
0FC1BH: ;
0FC1BH: ; (At least 9 bytes are used, maybe more)
0FC1BH: ;
0FC1BH: BUFFER:   ; 0FC1BH
0FC1BH: 	DB 0,0,0,0
0FC1FH: ;
0FC1FH: ; Buffer often written to 51H (3 bytes or 1 byte)
0FC1FH: ;
0FC1FH: DATA51H_3:   ; 0FC1FH
0FC1FH: 	DB 0,0,0,0
0FC23H: ;
0FC23H: ; 0-3, boot drive
0FC23H: ;
0FC23H: DRIVE:   ; 0FC23H
0FC23H: 	DB 0,0,0,0,0,0,0
0FC2AH: PORT51_INDATA:   ; 0FC2AH
0FC2AH: 	DB 0
0FC2BH: ;
0FC2BH: ; Another 0/1 flag
0FC2BH: ;
0FC2BH: FLAG2:   ; 0FC2BH
0FC2BH: 	DB 0,0,0,0,0,0,0,0
0FC33H: ;
0FC33H: ; 00, 01 or 7F
0FC33H: ;
0FC33H: FLAG3:   ; 0FC33H
0FC33H: 	DB 0
0FC34H: ;
0FC34H: ; Interrupt code does nothing if set to 1
0FC34H: ;
0FC34H: SKIP_INTERRUP:   ; 0FC34H
0FC34H: 	DB 0
0FC35H: XXX_PTR1:   ; 0FC35H
0FC35H: 	DW 0
0FC37H: XXX_PTR2:   ; 0FC37H
0FC37H: 	DW 0
0FC39H: XXX_PTR3:   ; 0FC39H
0FC39H: 	DW 0
0FC3BH: ;
0FC3BH: ; Looks like a length, inited to 00FF at @F984H
0FC3BH: ;
0FC3BH: XXX_LEN4:   ; 0FC3BH
0FC3BH: 	DW 0
0FC3DH: ;
0FC3DH: ; Looks like PROLOGUE load address
0FC3DH: ; 0110H by default
0FC3DH: ;
0FC3DH: BOOT_HL:   ; 0FC3DH
0FC3DH: 	DW 0
0FC3FH: ;
0FC3FH: ; Looks like a 256 bytes buffer
0FC3FH: ;
0FC3FH: XXX_BUFFER:   ; 0FC3FH
0FC3FH: 	DW 0,0
0FC43H: 	DW 0,0
0FC47H: 	DW 0,0
0FC4BH: 	DW 0,0
0FC4FH: 	DW 0,0
0FC53H: 	DW 0,0
0FC57H: 	DW 0,0
0FC5BH: 	DW 0,0
0FC5FH: 	DW 0,0
0FC63H: 	DW 0,0
0FC67H: 	DW 0,0
0FC6BH: 	DW 0,0
0FC6FH: 	DW 0,0
0FC73H: 	DW 0,0
0FC77H: 	DW 0,0
0FC7BH: 	DW 0,0
0FC7FH: 	DW 0,0
0FC83H: 	DW 0,0
0FC87H: 	DW 0,0
0FC8BH: 	DW 0,0
0FC8FH: 	DW 0,0
0FC93H: 	DW 0,0
0FC97H: 	DW 0,0
0FC9BH: 	DW 0,0
0FC9FH: 	DW 0,0
0FCA3H: 	DW 0,0
0FCA7H: 	DW 0,0
0FCABH: 	DW 0,0
0FCAFH: 	DW 0,0
0FCB3H: 	DW 0,0
0FCB7H: 	DW 0,0
0FCBBH: 	DW 0,0
0FCBFH: 	DW 0,0
0FCC3H: 	DW 0,0
0FCC7H: 	DW 0,0
0FCCBH: 	DW 0,0
0FCCFH: 	DW 0,0
0FCD3H: 	DW 0,0
0FCD7H: 	DW 0,0
0FCDBH: 	DW 0,0
0FCDFH: 	DW 0,0
0FCE3H: 	DW 0,0
0FCE7H: 	DW 0,0
0FCEBH: 	DW 0,0
0FCEFH: 	DW 0,0
0FCF3H: 	DW 0,0
0FCF7H: 	DW 0,0
0FCFBH: 	DW 0,0
0FCFFH: 	DW 0,0
0FD03H: 	DW 0,0
0FD07H: 	DW 0,0
0FD0BH: 	DW 0,0
0FD0FH: 	DW 0,0
0FD13H: 	DW 0,0
0FD17H: 	DW 0,0
0FD1BH: 	DW 0,0
0FD1FH: 	DW 0,0
0FD23H: 	DW 0,0
0FD27H: 	DW 0,0
0FD2BH: 	DW 0,0
0FD2FH: 	DW 0,0
0FD33H: 	DW 0,0
0FD37H: 	DW 0,0
0FD3BH: 	DW 0,0
0FD3FH: 	DW 0,0
0FD43H: 	DW 0,0
0FD47H: 	DW 0,0
0FD4BH: 	DW 0,0
0FD4FH: 	DW 0,0
0FD53H: 	DW 0,0
0FD57H: 	DW 0,0
0FD5BH: 	DW 0
0FD5DH: ;
0FD5DH: ; Location of the cursor in the SCREEN area.
0FD5DH: ; Before CURSOR, the inital Stack Frame
0FD5DH: ;
0FD5DH: CURSOR:   ; 0FD5DH
0FD5DH: 	DB 0,0
0FD5FH: ;
0FD5FH: ; 32 bytes for the screen buffer.
0FD5FH: ; Cursor is represented by '_'
0FD5FH: ;
0FD5FH: SCREEN:   ; 0FD5FH
0FD5FH: 	DB 0,0,0,0,0,0,0,0
0FD67H: 	DB 0,0,0,0,0,0,0,0
0FD6FH: 	DB 0,0,0,0,0,0,0,0
0FD77H: 	DB 0,0,0,0,0,0,0,0
0FD7FH: OTHER:   ; 0FD7FH
0FD7FH: 	DB 0,0,0,0,0,0,0,0
0FD87H: 	DB 0,0,0,0,0,0,0,0
0FD8FH: 	DB 0,0,0,0,0,0,0,0
0FD97H: 	DB 0,0,0,0,0,0,0,0
0FD9FH: 	DB 0,0,0,0,0,0,0,0
0FDA7H: 	DB 0,0,0,0,0,0,0,0
0FDAFH: 	DB 0,0,0,0,0,0,0,0
0FDB7H: 	DB 0,0,0,0,0,0,0,0
0FDBFH: 	DB 0,0,0,0,0,0,0,0
0FDC7H: 	DB 0,0,0,0,0,0,0,0
0FDCFH: 	DB 0,0,0,0,0,0,0,0
0FDD7H: 	DB 0,0,0,0,0,0,0,0
0FDDFH: 	DB 0,0,0,0,0,0,0,0
0FDE7H: 	DB 0,0,0,0,0,0,0,0
0FDEFH: 	DB 0,0,0,0,0,0,0,0
0FDF7H: 	DB 0,0,0,0,0,0,0,0
0FDFFH: 	DB 0,0,0,0,0,0,0,0
0FE07H: 	DB 0,0,0,0,0,0,0,0
0FE0FH: 	DB 0,0,0,0,0,0,0,0
0FE17H: 	DB 0,0,0,0,0,0,0,0
0FE1FH: 	DB 0,0,0,0,0,0,0,0
0FE27H: 	DB 0,0,0,0,0,0,0,0
0FE2FH: 	DB 0,0,0,0,0,0,0,0
0FE37H: 	DB 0,0,0,0,0,0,0,0
0FE3FH: 	DB 0,0,0,0,0,0,0,0
0FE47H: 	DB 0,0,0,0,0,0,0,0
0FE4FH: 	DB 0,0,0,0,0,0,0,0
0FE57H: 	DB 0,0,0,0,0,0,0,0
0FE5FH: 	DB 0,0,0,0,0,0,0,0
0FE67H: 	DB 0,0,0,0,0,0,0,0
0FE6FH: 	DB 0,0,0,0,0,0,0,0
0FE77H: 	DB 0,0,0,0,0,0,0,0
0FE7FH: 	DB 0,0,0,0,0,0,0,0
0FE87H: 	DB 0,0,0,0,0,0,0,0
0FE8FH: 	DB 0,0,0,0,0,0,0,0
0FE97H: 	DB 0,0,0,0,0,0,0,0
0FE9FH: 	DB 0,0,0,0,0,0,0,0
0FEA7H: 	DB 0,0,0,0,0,0,0,0
0FEAFH: 	DB 0,0,0,0,0,0,0,0
0FEB7H: 	DB 0,0,0,0,0,0,0,0
0FEBFH: 	DB 0,0,0,0,0,0,0,0
0FEC7H: 	DB 0,0,0,0,0,0,0,0
0FECFH: 	DB 0,0,0,0,0,0,0,0
0FED7H: 	DB 0,0,0,0,0,0,0,0
0FEDFH: 	DB 0,0,0,0,0,0,0,0
0FEE7H: 	DB 0,0,0,0,0,0,0,0
0FEEFH: 	DB 0,0,0,0,0,0,0,0
0FEF7H: 	DB 0,0,0,0,0,0,0,0
0FEFFH: 	DB 0,0,0,0,0,0,0,0
0FF07H: 	DB 0,0,0,0,0,0,0,0
0FF0FH: 	DB 0,0,0,0,0,0,0,0
0FF17H: 	DB 0,0,0,0,0,0,0,0
0FF1FH: 	DB 0,0,0,0,0,0,0,0
0FF27H: 	DB 0,0,0,0,0,0,0,0
0FF2FH: 	DB 0,0,0,0,0,0,0,0
0FF37H: 	DB 0,0,0,0,0,0,0,0
0FF3FH: 	DB 0,0,0,0,0,0,0,0
0FF47H: 	DB 0,0,0,0,0,0,0,0
0FF4FH: 	DB 0,0,0,0,0,0,0,0
0FF57H: 	DB 0,0,0,0,0,0,0,0
0FF5FH: 	DB 0,0,0,0,0,0,0,0
0FF67H: 	DB 0,0,0,0,0,0,0,0
0FF6FH: 	DB 0,0,0,0,0,0,0,0
0FF77H: 	DB 0,0,0,0,0,0,0,0
0FF7FH: 	DB 0,0,0,0,0,0,0,0
0FF87H: 	DB 0,0,0,0,0,0,0,0
0FF8FH: 	DB 0,0,0,0,0,0,0,0
0FF97H: 	DB 0,0,0,0,0,0,0,0
0FF9FH: 	DB 0,0,0,0,0,0,0,0
0FFA7H: 	DB 0,0,0,0,0,0,0,0
0FFAFH: 	DB 0,0,0,0,0,0,0,0
0FFB7H: 	DB 0,0,0,0,0,0,0,0
0FFBFH: 	DB 0,0,0,0,0,0,0,0
0FFC7H: 	DB 0,0,0,0,0,0,0,0
0FFCFH: 	DB 0,0,0,0,0,0,0,0
0FFD7H: 	DB 0,0,0,0,0,0,0,0
0FFDFH: 	DB 0,0,0,0,0,0,0,0
0FFE7H: 	DB 0,0
	END
