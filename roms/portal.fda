LABEL 000AH CODE BOOT_LOOP
LABEL 0017H CODE BOOT_START
COMMENT LABEL BOOT_START "This is the code that is copied to F800 at boot time"
LABEL 0110H CODE PROLOGUE
COMMENT LABEL PROLOGUE "The address where PROLOGUE is loaded in memory"
LABEL 0432H DATA BOOT_UNUSED
COMMENT LABEL BOOT_UNUSED "Unused ROM space"
LABEL F7E9H CODE IGNORE
COMMENT LABEL IGNORE "R2E Micral Portal boot rom disassembly (in progress) \nThis code is executed from 0 and copies the rest into F800 in RAM"
LABEL F7F8H CODE INT_VECTOR
COMMENT LABEL INT_VECTOR "Copies the code 'JMP FA7A' (HOOK) here\nThis is also written to by F809H and becomes @INT_VECTOR\n(JMP @FA7AH / JMP @INTERRUPT)\nPIC sets interrupts to be at F7E0+4*INT#, so this is INT 6."
LABEL F800H CODE RAM_START
COMMENT LABEL RAM_START "The real start in RAM\nPorts:\n  11: 00\n  60: F6\n  61: F7 BF"
LABEL F824H CODE MONITOR
COMMENT LABEL MONITOR "Resets stack, print "
LABEL F839H CODE MONITOR2
LABEL F861H CODE CMD_B
COMMENT LABEL CMD_B "Here the 'B' (Boot ?) command starts\nAsks for a 0-3 number (drive #?)\nthen a 4 hex number (#of bytes to read? sector?)\nand executes the 'ENTER' function (real boot)"
LABEL F879H CODE CMD_ENTER
COMMENT LABEL CMD_ENTER "B : Drive #"
LABEL F886H CODE WAIT_LOOP
LABEL F8DEH CODE SKIP_383
LABEL F8EFH CODE AGAIN
COMMENT LABEL AGAIN "Redoes whatever this function tries to do.\nWEIRD ends here if C is zero"
LABEL F912H CODE DF912
LABEL F92CH CODE DF92C
LABEL F932H CODE DF932
LABEL F93EH CODE DF93E
COMMENT LABEL DF93E "After the call to @WEIRD, it does something strange:\nBreaks A into 4 groups of two bits\nEnsure those groups are 00 or 01\nWhen they are 01, it adds DE to (HL,H+1)\nHL is in incremented between each loop."
LABEL F943H CODE LOOP_383
LABEL F955H CODE SKIP_ADD
LABEL F95DH CODE JMP_HL
COMMENT LABEL JMP_HL "Jumps to content of HL"
LABEL F95EH CODE WEIRD
COMMENT LABEL WEIRD "Weird function with a spurious POP if C is zero...\nIf C is not zero it reads one byte from @XXX_PTR3"
LABEL F968H CODE NON_ZERO_C
COMMENT LABEL NON_ZERO_C "Called when C is not Zero. Why? No idea yet.\nReads one byte out of @XXX_PTR3 until @XXX_LEN4 is zero\nResets @XXX_LEN4 to FF and @XXX_PTR to @XXX_BUFFER at last element"
LABEL F971H CODE EMPTY
COMMENT LABEL EMPTY "Buffer is empty"
LABEL F990H CODE NOT_EMPTY
LABEL F997H CODE DF997
LABEL F99FH CODE DIV_AND_OTHERS
COMMENT LABEL DIV_AND_OTHERS "Divides HL by E\n  (E may be C6H (198) from '@CMD_ENTER'?)\nIt then do stuff and return HL+1"
LABEL F9A4H CODE LOOP
COMMENT LABEL LOOP "16 times (every bit of HL)"
LABEL F9ADH CODE BIT7
LABEL F9AFH CODE SKIP_217
LABEL F9CEH CODE SKIP
LABEL F9E8H CODE LOOP_609
LABEL FA0EH CODE DFA0E
LABEL FA1EH CODE MEMCPY
COMMENT LABEL MEMCPY "Copies C bytes from HL to DE"
LABEL FA27H CODE DFA27
COMMENT LABEL DFA27 "HL = @BUFFER + @DRIVE & 0x3"
LABEL FA34H CODE XXX_635
LABEL FA7AH CODE INTERRUPT
COMMENT LABEL INTERRUPT "Interrupt?\nStored as the target of a JMP instruction in 0008\n(See RAM_START)"
LABEL FA84H CODE INTERRUPT_READ
COMMENT LABEL INTERRUPT_READ "Reads from 51H"
LABEL FA9AH CODE INTERRUPT_RETURN
COMMENT LABEL INTERRUPT_RETURN "Returns with a code (in @FLAG3)"
LABEL FA9DH CODE INTERRUPT_END
LABEL FAA5H CODE INTERRUPT_ERROR
COMMENT LABEL INTERRUPT_ERROR "I suspect this is an error code"
LABEL FAAAH CODE INTERRUPT_RETRY
COMMENT LABEL INTERRUPT_RETRY "I guess this is a retry to get some data\n(writes 1 in bit 4 of 51H)"
LABEL FAB7H CODE READ_51H
COMMENT LABEL READ_51H "Reads from 51H into PORT51_INDATA\nReads as long as 50H bits 6 and 7 are set\nStops if 50H has bit 7 set and bit 5 cleared\nB contains number of bytes read\nAlso called from interrupt"
LABEL FABCH CODE LOOP_576
LABEL FAD3H CODE WRITE_51H
COMMENT LABEL WRITE_51H "Write C chars into HL (from floppy?)\nWaits for 50H bit 4 to clear\nThen similar logic to READ:\nWaits for bit 7 set and 6 cleared"
LABEL FADAH CODE WRITE2_51H
COMMENT LABEL WRITE2_51H "Writes C chars from HL to 51H\n(waits for 50H bit 7 to be set)"
LABEL FAEDH CODE XXX_891
COMMENT LABEL XXX_891 "Suspects that is is read from floppy sync"
LABEL FAF5H CODE BUSY_LOOP
LABEL FAFDH STRF2 DATA_S0
COMMENT LABEL DATA_S0 "2 bytes of data "
LABEL FAFFH DATA DATA_TR
COMMENT LABEL DATA_TR "Maybe track count? Inited at 40..."
LABEL FB00H DATA DATA_X4
COMMENT LABEL DATA_X4 "4 bytes of data\n"
LABEL FB05H CODE READ_HL
COMMENT LABEL READ_HL "Reads HL in hex\nDigits must be entered and finished with ESC\nMy understanding is that we will crash at the 8th digit"
LABEL FB0BH CODE LOOP_811
LABEL FB23H CODE SKIP_442
LABEL FB33H CODE FAILED
LABEL FB3CH CODE DONE
LABEL FB3EH CODE CMD_STAR
COMMENT LABEL CMD_STAR "Infinite loop with echo of the typed char (if not space).\nMay be a keyboard tester"
LABEL FB40H CODE LOOP_230
LABEL FB58H CODE LF
LABEL FB60H CODE CONT
LABEL FB66H CODE CMD_G
COMMENT LABEL CMD_G "User typed 'G' in the monitor"
LABEL FB6DH CODE CMD_AMP
COMMENT LABEL CMD_AMP "User typed '&' in the monitor"
LABEL FB79H CODE MONITOR_REENTER
COMMENT LABEL MONITOR_REENTER "Display '#' and goes to monitor"
LABEL FB81H CODE WAIT_KEY
COMMENT LABEL WAIT_KEY "Waits for a char and reads it in A"
LABEL FB8CH STRZ PSTR_PORTAL
COMMENT LABEL PSTR_PORTAL "TAB+SPACE+PORTAL"
LABEL FB8DH STRZ STR_PORTAL
LABEL FB97H CODE READ_CHAR_ECHO
COMMENT LABEL READ_CHAR_ECHO "Read char with echo\nReturns char in C"
LABEL FB9BH CODE PRINT_CHAR
COMMENT LABEL PRINT_CHAR "Prints char in C"
LABEL FBB7H CODE PRINT_CR
COMMENT LABEL PRINT_CR "Erase current cursor and put cursor at start of screen"
LABEL FBCCH CODE UPDATE_SCREEN
COMMENT LABEL UPDATE_SCREEN "Outputs the content of @SCREEN to ports 9F downto 80 "
LABEL FBD3H CODE LOOP_737
LABEL FBE7H CODE PRINT_LF
COMMENT LABEL PRINT_LF "Clear screen, put cursor at column 0"
LABEL FBF2H CODE NEXT_COLUMN
LABEL FC0CH CODE PRINT_PSTR
COMMENT LABEL PRINT_PSTR "Prints pascal string pointed by HL\nFirst byte is length"
LABEL FC0FH CODE LOOP_874
LABEL FC1BH DATA BUFFER
COMMENT LABEL BUFFER "(At least 9 bytes are used, maybe more)"
LABEL FC1FH DATA DATA51H_3
COMMENT LABEL DATA51H_3 "Buffer often written to 51H (3 bytes or 1 byte)"
LABEL FC23H DATA DRIVE
COMMENT LABEL DRIVE "0-3, boot drive"
LABEL FC2AH DATA PORT51_INDATA
LABEL FC2BH DATA FLAG2
COMMENT LABEL FLAG2 "Another 0/1 flag"
LABEL FC33H DATA FLAG3
COMMENT LABEL FLAG3 "00, 01 or 7F"
LABEL FC34H DATA SKIP_INTERRUP
COMMENT LABEL SKIP_INTERRUP "Interrupt code does nothing if set to 1"
LABEL FC35H DATAW XXX_PTR1
LABEL FC37H DATAW XXX_PTR2
LABEL FC39H DATAW XXX_PTR3
LABEL FC3BH DATAW XXX_LEN4
COMMENT LABEL XXX_LEN4 "Looks like a length, inited to 00FF at @F984H"
LABEL FC3DH DATAW BOOT_HL
COMMENT LABEL BOOT_HL "Looks like PROLOGUE load address\n0110H by default"
LABEL FC3FH DATAW XXX_BUFFER
COMMENT LABEL XXX_BUFFER "Looks like a 256 bytes buffer"
LABEL FD5DH DATA CURSOR
COMMENT LABEL CURSOR "Location of the cursor in the SCREEN area.\nBefore CURSOR, the inital Stack Frame"
LABEL FD5FH DATA SCREEN
COMMENT LABEL SCREEN "32 bytes for the screen buffer.\nCursor is represented by '_'"
LABEL FD7FH DATA OTHER
COMMENT LINE F812H "HI(@INTERRUPT)"
COMMENT LINE 0014H "Boot"
COMMENT LINE 0001H "0017 at boot time"
COMMENT LINE F80CH "JMP"
COMMENT LINE F850H "':'"
COMMENT LINE FBBBH "' '"
COMMENT LINE FBDAH "Will be patched"
COMMENT LINE FBD1H "Port"
COMMENT LINE FB84H "Wait for char"
COMMENT LINE FB89H "Force ASCII"
COMMENT LINE FB81H "Char READY (bit 0)"
COMMENT LINE FB87H "Char"
COMMENT LINE FB83H "Bit 0 -> Carry"
COMMENT LINE FB44H "\n"
COMMENT LINE FB49H "\r"
COMMENT LINE FC0EH "Length"
COMMENT LINE FB79H "'#'"
COMMENT LINE FB60H "Useless should have been FB5A"
COMMENT LINE F821H "Some flag?"
COMMENT LINE FB6CH "Jumpto address"
COMMENT LINE FB8CH "9 Bytes string"
COMMENT LINE F841H "'&' command"
COMMENT LINE F847H "'\n' command"
COMMENT LINE F84CH "'*' command"
COMMENT LINE F858H "'G' command"
COMMENT LINE FBEBH "' '"
COMMENT LINE FBF0H "Do 32 times (32 characters)"
COMMENT LINE FBF5H "Copies 32 spaces"
COMMENT LINE FBFBH "'_'"
COMMENT LINE FBAFH "'_'"
COMMENT LINE FBC4H "'_'"
COMMENT LINE F88BH "Loops 33990 times"
COMMENT LINE F963H "Weird..."
COMMENT LINE F964H "C = 1"
COMMENT LINE F965H "Again"
COMMENT LINE FB11H "Fails if <'0'"
COMMENT LINE FB16H "Fails if original char >'F'"
COMMENT LINE FB1BH "Jumps if original was 'A'-'F'"
COMMENT LINE FB0FH "; '0' is at 0"
COMMENT LINE FB14H "'F' is at FF"
COMMENT LINE FB19H "'A' is at 0"
COMMENT LINE FB1EH "'9' is at FF"
COMMENT LINE FB20H "Jumps if orignal >'9' and <'A'"
COMMENT LINE FB23H "'0' is at 0, 'F' at 15"
COMMENT LINE FB2AH "*2"
COMMENT LINE FB2BH "*4"
COMMENT LINE FB2CH "*8"
COMMENT LINE FB2DH "*16"
COMMENT LINE FB2EH "Why?"
COMMENT LINE FB25H "Why?"
COMMENT LINE FB2FH "Replace last hex digit"
COMMENT LINE FB34H "ESC"
COMMENT LINE FB36H "Only correct way to exit"
COMMENT LINE FB3AH "Error"
COMMENT LINE FB3BH "Return"
COMMENT LINE FB3CH "Why?"
COMMENT LINE FB09H "Read at most 8 hex chars"
COMMENT LINE FB06H "Starts with 0000"
COMMENT LINE FB0BH "Read one digit"
COMMENT LINE FB27H "Will crash because lack of POP B"
COMMENT LINE F86FH "Must be 0 to 3"
COMMENT LINE FB4EH "0AH initial call"
COMMENT LINE FAC3H "0010 0000"
COMMENT LINE FABFH "Wait for bit 7"
COMMENT LINE F9ADH "L |= 1"
COMMENT LINE F9AAH "A < E"
COMMENT LINE F9A5H "A gets the high bit of HL"
COMMENT LINE F9A4H "C = HL & 8000 ; HL <<= 1"
COMMENT LINE FA98H "Signal we are done"
COMMENT LINE F882H "33990 (loop counter)"
COMMENT LINE F80FH "LOW(@INTERRUPT)"
COMMENT LINE FAC5H "Return if 5th bit clear"
COMMENT LINE FAC8H "Wait for bit 6"
COMMENT LINE F9FFH "Read 9 bytes"
COMMENT LINE FAB1H "Write [0x08]"
COMMENT LINE F9DDH "01 10 20 00"
COMMENT LINE F8B4H "Drive 0 & 1"
COMMENT LINE F8B7H "Drive 2 & 3"
COMMENT LINE F861H "Drive #"
COMMENT LINE F836H "Can be changed by the @CMD_B command. I Suspect it is some track/sector"
COMMENT LINE F839H "0 to 3, can be changed by @CMD_B command"
COMMENT LINE F873H "Size? Len? @F836H (defaults to 0080)"
COMMENT LINE F886H "Waste some cycles"
COMMENT LINE F8ABH "Contains [3,'S','0']"
COMMENT LINE F8C7H "Wtf is this code?"
COMMENT LINE F8D0H "We juste did an MVI A,46H"
COMMENT LINE F8C8H "?"
COMMENT LINE F8CAH "?"
COMMENT LINE F8CBH "?"
COMMENT LINE F8CCH "?"
COMMENT LINE F8CDH "?"
COMMENT LINE F8CEH "?"
COMMENT LINE F8D8H "Why?"
COMMENT LINE F8DAH "C is always 0"
COMMENT LINE FAFFH "28H = 40. Tracks?"
COMMENT LINE FAF5H "Interrup will set this to 1"
COMMENT LINE F87BH "We skip interrupt code"
COMMENT LINE F890H "We activate the @INTERRUPT code"
COMMENT LINE FA81H "Skip interrupt code"
COMMENT LINE FA89H "B=0 => No data read"
COMMENT LINE F814H "ICW1 : PIC init word 1"
COMMENT LINE F81CH "ICW3 : PIC init word 3"
COMMENT LINE F818H "ICW2 : PIC init word 2 (interrupt at F7E0+4*INT)"
COMMENT LINE FAB7H "Actually @FLAG2-1"
COMMENT LINE FACDH "@FLAG2 (@PORT51_INDATA+1)"
COMMENT LINE FA87H "B is length (0 or 1)"
COMMENT LINE FA8FH "Data read from 51H"
COMMENT LINE FA91H "Checks it is 0xxxxxxx"
COMMENT LINE FA95H "Checks it is 00xxxxxx"
COMMENT LINE F893H "0080 or something that was entered with the 'B' command"
COMMENT LINE F8D5H "Contains 28H"
COMMENT LINE F8E0H "Normally will put 10H in L (from @FB01H)"
COMMENT LINE FA9DH "(Probably some sort of acknowledgment)"
COMMENT LINE F802H "Unmap ROM (set 40H to put ROM back)"
COMMENT LINE F830H "Load adrs. Can be changed by the @CMD_AMP command"
COMMENT LINE F8F2H "A=0 ?"
COMMENT LINE F91FH "Execute some loaded code?"
COMMENT LINE F937H "Looks like we are trying to write to ROM"
COMMENT LINE F999H "XXX_PTR3++ or XXX_PTR3=&XXX_BUFFER after every 256 bytes"
COMMENT LINE F7EAH "From address 0017H"
COMMENT LINE F7EDH "Copy 041CH bytes (1052 bytes)"
COMMENT LINE F7F0H "To location @RAM_START..."
COMMENT LINE F7FDH "Jump to copied code"
COMMENT LINE F7FAH "This is @f7f3H in offseted binary"
COMMENT LINE F8F6H "C = GET()"
COMMENT LINE F8FAH "B = GET()"
COMMENT LINE F8FEH "IF C < 3 ..."
COMMENT LINE F904H "H = GET()"
COMMENT LINE F908H "L = GET()"
COMMENT LINE F90CH "IF GET()&1 THEN DE++"
COMMENT LINE F915H "IF B=C2 THEN F932"
COMMENT LINE F91AH "IF B=D2 THEN F93E"
COMMENT LINE F924H "IF B=C1 THEN ABORT()"
COMMENT LINE F929H "IF B=DB THEN ABORT()"
COMMENT LINE F92FH "FOR (;;) GET()"
COMMENT LINE F94EH "(HL) += E"
COMMENT LINE F952H "(HL+1) += D (with carry from above)"
COMMENT LINE F941H "Will work on the 4 group of 2 bits"
COMMENT LINE F944H "10 or 11 => ABORT()"
COMMENT LINE F94BH "All this does: (HL,HL+1) += DE"
COMMENT LINE F960H "If C!=0 GOTO NON_ZERO_C"
COMMENT LINE F987H "@XXX_LEN4 = FF"
COMMENT LINE F969H "HL = @XXX_LEN4"
COMMENT LINE F96EH "IF HL != 0 GOTO NOT_EMPTY"
COMMENT LINE F990H "HL--"
COMMENT LINE F991H "@XXX_LEN4 = HL"
COMMENT LINE F997H "Get next from @XXX_PTR3"
COMMENT LINE F998H "@XXX_PTR3++"
COMMENT LINE F98AH "HL = &XXX_BUFFER (reset @XXX_PTR3 buffer)"
COMMENT LINE FBFDH "First char is '_'"
COMMENT LINE FC04H "@CURSOR = @SCREEN (left column)"
COMMENT LINE F8ECH "The buffer starts empty"
COMMENT LINE F97BH "???"
COMMENT LINE F97EH "HL++"
COMMENT LINE FB50H "32nd column"
COMMENT LINE FB3EH "Current column"
IO 00H PORT00 "[should not be visible as there is no port 00H usage]"
IO 10H KBDSTROBE "Bit 0 is 1 if key presse (see @WAIT_KEY)\n\nADSC    EQU     010H    ;ADRESSE PRINTER + ADRESSE STATUS\n"
IO 11H KDBDATA "Keyboard read data (maybe something else when writing?)\nNeeds AND with 7FH"
IO 50H PROBE51H "Probe for writing in 51H\nGenerally waits for bit 4 to be zero and bit 7 to be zero"
IO 60H PIC1 "8259 Port 0"
IO 61H PIC2 "8259 Port 1"
IO 9FH SCRN00 "First char of screen (80-9F, one port per on-screen character)"
